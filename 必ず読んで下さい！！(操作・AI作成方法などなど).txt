＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
＊＊＊ 注意! 必ず読み飛ばさず、上から順番に読んで下さい。 ＊＊＊
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
2016/11/16 ・getPlayer～関数の説明誤りを修正
           ・getJumpRemain関数の名前が誤っていたのを修正
           ・使用可能な情報の入った変数の説明を関数一覧の下に追加

■ ゲーム概要 ■
本ゲームは2016年度調布祭のAI対戦用に作られたものです。
人間が操作して遊ぶのではなく、人間があらかじめ設計したAIを元に動くキャラクター達が自動で戦います。
AIの設計のための言語には、Microsoft Visual C++を使用します。


■ 仕様 ■
本ゲームは某大乱闘ゲームをリスペクトしたもので、以下のような仕様です(昨年度『Enogoon』と似たような設計です)。

★すべてのキャラクターはステップと呼ばれるターンごとに行動します。
★1ステップにつき1つの行動を選択します。
★行動は「待機(何もしない)」「左へ移動」「右へ移動」「左を向く」「右を向く」「ジャンプ」「(通り抜け可能な床を)降りる」「攻撃」「防御」の9種類から選択します。
★フィールドはマス目状になっており、移動はその方向へ1マス移動、ジャンプは上方向へ2マス移動します。攻撃は自分の向いている方向へ1マス横にいる敵が対象です。
★重力により、空中にいるキャラクターは1ステップあたり1マス、自動的に下方向へ移動されます(たとえば空中で横方向移動すると斜め下に移動します)。
★2段ジャンプが可能です。つまり空中でのジャンプが1回可能です。
★攻撃を受けるとダメージが蓄積され、ダメージが大きくなるほど攻撃を受けたときに吹っ飛ばされやすくなります。吹っ飛ぶマス数は「ダメージ率(%)/25」の2乗です。
★攻撃を受けたステップでの移動は取り消されます。
★「攻撃」の行動を連続して選択していると、通常3%の攻撃ダメージが連続回数ごとに3→4→5→6と増えていきます。ダメージ上昇は最大で6%までです。
★「防御」の行動を選択すると、そのステップでの相手からの攻撃を防御できます。「防御」は連続では選択できず、次の防御までに3ステップ以上別の行動を選択する必要があります。
★落下などでフィールドの範囲外に出ると、自分の得点が-1され、最後に攻撃したプレイヤーに得点が+1されます。
　ただし、誰にも攻撃されていない場合や最後に複数の敵に同時攻撃された場合は、自分の得点が-1されるだけで、他のプレイヤーに得点が入ることはありません。
★制限時間経過後、得点を元に順位が表示されます。複数のプレイヤーの得点が同一である場合は、ダメージ率が小さい順に順位を決定します。
★フィールドはデフォルトで4種類用意されています。


■ メニューの操作方法 ■
矢印キー : カーソル移動
Zキー    : 決定
Xキー    : 取り消し
Enterキー: スタート

Ctrlキー : (プレイ中に押しっぱなしで)早送り


■ 設定について ■
デフォルトではステップの概念がわかりやすいよう、1ステップおきに待ち時間を入れています。
config.iniを開き、「FRAME_WAIT=10」の行を「FRAME_WAIT=0」に書き換えるとスムーズに動きます。

また、デフォルトではマス目がわかりやすいよう2Dモードになっています。
「MODE_2D=1」の行を「MODE_2D=0」に書き換えると、某大乱闘ゲームみたいなカッコイイ見た目のフィールドになります。


■ AIの登録方法について ■
AIのプロジェクトをMicrosoft Visual StudioでビルドするとReleaseフォルダの中に「MyTerefamiAI.dll」が生成されます。
これをゲーム本体の「ai」フォルダに入れると、AIが追加されます。dllファイル以外にReleaseフォルダ内に生成されているファイルをコピーする必要はありません。
dllファイルのファイル名は「MyTerefamiAI.dll」となっているので、適宜好きなファイル名に変更して下さい。

※ビルド時に「プログラム'○○○○○.dll'を開始できません。」と表示されますが、これは生成されたdllファイルを実行ファイルとして"実行"しようとするために表示されるダイアログです。
　これは正常にdllファイルが生成された際に表示されるものなので、OKを押してそのままダイアログを閉じて下さい。


■ AI作成の前に ■
まずはゲーム本体(terefami.exe)を実行してみましょう。

標準では「完全ランダム」と「敵がいたら攻撃」という2種類のAIがサンプルとして用意されています。

「完全ランダム」は、9種類の行動からランダムに選んだ行動を実行するAIです。
「敵がいたら攻撃」は、自分の向いている方向に敵がいたら「攻撃」し、それ以外はランダムに行動するAIです。

それぞれ4体ずつ選択して戦わせてみて下さい(左右キーでカーソル移動、Zキーでキャラ選択、Enterキーでゲーム開始、ゲーム中はCtrlキーで早送り)。
フィールドによっても差が出てくると思いますが、恐らく「敵がいたら攻撃」の方が順位が上になることが多いのではないかと思います。

このことから、当てずっぽうに攻撃する「完全ランダム」より、敵をめがけて攻撃する「敵がいたら攻撃」の方が強いことがわかるでしょう。

どうすれば強いAIになるかを考えて、これらのAIを自分なりに改造してみましょう。


■ AIの作成方法 ■
「samples」フォルダには、先ほど挙げた「完全ランダム」と「敵がいたら攻撃」のサンプルAIのプロジェクトが用意されています。
いずれかのプロジェクトをフォルダごとどこかへコピーして、「MyTerefamiAI.sln」を開いて下さい。

編集するのは「ai.cpp」です(それ以外のソースファイルは編集しないで下さい)。

まず「■①」と「■②」と書かれた部分を編集し、AIの名前と画像ファイル名(PNG形式)を指定して下さい。
PNG画像ファイルは縦横比1:1で作成し、ゲーム本体の「ai」フォルダに入れて下さい。
画像を作るのが面倒であれば、「ika.png」などがサンプルとして用意されているのでそれを指定して下さい(ただ提出時にはなるべくオリジナルの画像で)。

次に、メインとなるAIの設計部分を見ていきます。
編集してもよい部分は、「//■■■ AI設計 ここから ■■■」から「//■■■ AI設計 ここまで ■■■」の間のみです(ただしライブラリ使用などの目的で先頭に追記するなどは構いません)。

ステップおきに processAI()関数 が呼ばれるので、この中で計算をし、そのステップでの行動を決定します。
行動は0～8の数字で関数の戻り値として指定します。例えば、processAI()関数内で「return 2;」と記述すれば、2の行動(右へ1マス移動)になります。

行動は以下の0～8があります。

○0: 待機(何もしない)
○1: 左へ1マス移動
○2: 右へ1マス移動
○3: その場で左を向く
○4: その場で右を向く
○5: ジャンプ(2マス上方移動)
○6: (通り抜け可能な床を)降りる
○7: 攻撃(自分の1つ前のマスが対象)
○8: 防御(次の防御までは最低3ステップの間隔が必要です)

例えば、

int processAI() {
    /* ゲーム中、ステップ毎に繰り返し実行されます */
    return 0;
}

とすれば、ずっと待機し続けるだけのAIになりますし、

int processAI() {
    /* ゲーム中、ステップ毎に繰り返し実行されます */
    return 7;
}

とすれば、その場で攻撃し続けるだけのAIになります。

サンプルの完全ランダムAIでは「return rand() % 9;」となっています。これは0～8の値をランダムで返しているということです(rand()はランダムな整数を発生させる関数、%は剰余を表す演算子なので、rand()%9は0～8のランダムな整数となる)。
これによって、0～8の行動をランダムに決定しています。

何も考えずに行動を決定するだけではつまらないので、フィールドや敵の情報を取得する関数を使用して、その場に応じた行動をとるAIを作成してみましょう。

例えば、サンプルの「敵がいたら攻撃」AIでは、getX、getY、getDirection、getEnemyCountという4種類の関数を使用して自分の前にいる敵の数を調べ、1体以上敵がいたら攻撃するという設計です。
getX()とgetY()は自分のいるマスの座標を取得する関数で、getDirection()は自分の向き(左:0、右:1)を取得する関数です。
また、getEnemyCount関数は座標を与えるとそのマスにいる敵の数が取得できる関数です。

サンプルAI「敵がいたら攻撃」の中で、

if (getEnemyCount(getX() + getDirection() * 2 - 1, getY()) > 0){
    return 7;
}

と書かれているのは、getEnemyCount関数に対して、自分のX座標であるgetX()にgetDirection()*2-1を足した座標、すなわち自分の向いている方向のX座標、および自分のY座標を渡すことで、
自分の目の前のマスにいる敵の数を調べ、1体以上いたら「return 7;」が実行される、ということです。

取得できる情報は他にもたくさんあります。詳しくは、後述の関数一覧をご覧下さい。

AI設計の際には、変数を宣言・使用しても構いません。以下の点に注意して下さい。
・int processAI(){～}内で宣言された変数はそのステップ限りの値で、ステップごとに初期化されます。
・int processAI(){～}の外で宣言された変数は、ステップを超えて値が引き継がれます(宣言の際に「static」などの指定子は不要です)。

また、もし一回だけ実行させたい処理などがあれば、initAI()関数内にその処理を書いて下さい(ゲーム開始時に一度だけ実行されます)。


■ 関数一覧 ■
-----------------------------------------------------------
＊＊＊ 自分の情報を取得する関数 ＊＊＊

○int getX
　自分のX座標を取得します。
　X座標は0以上の整数で取得されます。

○int getY
　自分のY座標を取得します。
　Y座標は0以上の整数で取得されます。

○int getDirection()
　自分の向きを取得します。
　左向きの場合は0、右向きの場合は1となります。

○int getDamage()
　自分のダメージ率(%)を取得します。
　ダメージ率は0以上の整数で取得されます。

○int getJumpRemain()
　自分の残りジャンプ可能回数を取得します。

○int getAttackCombo()
　自分の現在の連続攻撃回数を取得します。

-----------------------------------------------------------
＊＊＊ 敵などの情報を取得する関数(座標指定) ＊＊＊

○int getField(int x, int y)
　フィールド内の指定したマスの状態を取得します(空中:0、ブロック:1、通り抜け可能な床:2)。
　範囲外の座標を指定すると-1が戻ります。

○int getEnemyCount(int x, int y)
　フィールド内の指定したマスにいる敵の数を取得します。
　範囲外の座標を指定すると-1が戻ります。

○int getEnemyDirection(int x, int y)
　フィールド内の指定したマスにいる敵の向きを取得します(左:0、右:1)。
　範囲外の座標を指定すると-1が戻ります。
　敵が複数いる場合は-2が戻ります。

○int getEnemyDamage(int x, int y)
　フィールド内の指定したマスにいる敵のダメージ率(%)を取得します。
　範囲外の座標を指定すると-1が戻ります。
　敵が複数いる場合は-2が戻ります。

○int getEnemyJumpRemain(int x, int y)
　フィールド内の指定したマスにいる敵の残りジャンプ可能回数を取得します。
　範囲外の座標を指定すると-1が戻ります。
　敵が複数いる場合は-2が戻ります。

○int getEnemyAttackCombo(int x, int y)
　フィールド内の指定したマスにいる敵の現在の連続攻撃回数を取得します。
　範囲外の座標を指定すると-1が戻ります。
　敵が複数いる場合は-2が戻ります。

○int getEnemyID(int x, int y)
　フィールド内の指定したマスにいる敵のプレイヤーIDを取得します(プレイヤーIDは0～7の整数)。
　範囲外の座標を指定すると-1が戻ります。
　敵が複数いる場合は-2が戻ります。

-----------------------------------------------------------
＊＊＊ プレイヤーの情報を取得する関数(プレイヤーID指定) ＊＊＊

○int getPlayerX(int id)
　指定したIDのプレイヤーのX座標を取得します(プレイヤーIDは0～7の整数)。
　範囲外のプレイヤーIDを指定すると-1が戻ります。

○int getPlayerY(int id)
　指定したIDのプレイヤーのY座標を取得します(プレイヤーIDは0～7の整数)。
　範囲外のプレイヤーIDを指定すると-1が戻ります。

○int getPlayerDirection(int id)
　指定したIDのプレイヤーの向きを取得します(左:0、右:1)。
　範囲外のプレイヤーIDを指定すると-1が戻ります。

○int getPlayerDamage(int id)
　指定したIDのプレイヤーのダメージ率(%)を取得します。
　範囲外のプレイヤーIDを指定すると-1が戻ります。

○int getPlayerJumpRemain(int id)
　指定したIDのプレイヤーの残りジャンプ可能回数を取得します。
　範囲外のプレイヤーIDを指定すると-1が戻ります。

○int getPlayerAttackCombo(int id)
　指定したIDのプレイヤーの現在の連続攻撃回数を取得します。
　範囲外のプレイヤーIDを指定すると-1が戻ります。

-----------------------------------------------------------

なお各情報の入った変数として、
・playerID (自分のプレイヤーID)
・playerCount (プレイヤーの総数)
・fieldWidth (フィールドの横サイズ)
・fieldHeight (フィールドの縦サイズ)
が使用可能です。いずれもconst int型で、読み込み専用です。


■ AI作成上のルール ■
・AIの中でファイル操作を行うことは禁止します。
・AIの中でネットワークに接続させることは禁止します。
・AIの中にその他悪意のあるコードを埋め込むことを禁止します。
・AIの中で特殊なメモリ操作などを利用し、ゲーム内部の情報を読み出したり書き換えたりすることは禁止します。
　ゲーム内の情報の取得は上記関数一覧に載っている関数を利用して下さい。
・動作が保証できないと困るので、基本的にMicrosoft Visual C++以外でdllを作成することは避けて下さい。
・AIのプログラムは必ず1個のdllファイルで完結させるようにしてください(例えばAIのdllファイルに加えてさらにdllファイルが必要となるような計算ライブラリなどは使用できません)。
・用意された4種類のフィールドそれぞれに特化したAIを作成することは避けて下さい(例えばブロックの位置から4種類のうちどのフィールドか判別してそれを元に行動するようなAIの作成は避けて下さい)。